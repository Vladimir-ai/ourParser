%import common.DIGIT
%import common.ESCAPED_STRING
%import common.CNAME
%import common.NEWLINE
%import common.WS
%import common.C_COMMENT
%import common.CPP_COMMENT
%import common.LETTER
%import common.SIGNED_NUMBER
%import common.NUMBER
%import common.FLOAT
%import common.INT

DEC_NUMBER: /0|[1-9][\d_]*/i
HEX_NUMBER.2: /0x[\da-f]*/i
OCT_NUMBER.2: /0o[0-7]*/i
BIN_NUMBER.2 : /0b[0-1]*/i
FLOAT_NUMBER.2: /((\d+\.[\d_]*|\.[\d_]+)(e[-+]?\d+)?|\d+(e[-+]?\d+))/i
IMAG_NUMBER.2: /\d+j/i | FLOAT_NUMBER "j"i
//%import common.NUMBER

//num: (DEC_NUMBER | HEX_NUMBER | BIN_NUMBER | OCT_NUMBER | FLOAT | IMAG_NUMBER) -> literal
//NAME: /[a-zA-Z_]\w*/
//COMMENT: /#[^\n]*/
//
//STRING : /[ubf]?r?("(?!"").*?(?<!\\)(\\\\)*?"|'(?!'').*?(?<!\\)(\\\\)*?')/i
//LONG_STRING: /[ubf]?r?(""".*?(?<!\\)(\\\\)*?"""|'''.*?(?<!\\)(\\\\)*?''')/is
//
//DEC_NUMBER: /0|[1-9][\d_]*/i
//HEX_NUMBER.2: /0x[\da-f]*/i
//OCT_NUMBER.2: /0o[0-7]*/i
//BIN_NUMBER.2 : /0b[0-1]*/i
//FLOAT_NUMBER.2: /((\d+\.[\d_]*|\.[\d_]+)(e[-+]?\d+)?|\d+(e[-+]?\d+))/i
//IMAG_NUMBER.2: /\d+j/i | FLOAT_NUMBER "j"i

//?test: or_test ("if" or_test "else" test)? | lambdef
//?test_nocond: or_test | lambdef_nocond
//lambdef: "lambda" [varargslist] ":" test
//lambdef_nocond: "lambda" [varargslist] ":" test_nocond
//?or_test: and_test ("or" and_test)*
//?and_test: not_test ("and" not_test)*
//?not_test: "not" not_test -> not
//         | comparison
//?comparison: expr (_comp_op expr)*
//star_expr: "*" expr
//?expr: xor_expr ("|" xor_expr)*
//?xor_expr: and_expr ("^" and_expr)*
//?and_expr: shift_expr ("&" shift_expr)*
//?shift_expr: arith_expr (_shift_op arith_expr)*
//?arith_expr: term (_add_op term)*
//?term: factor (_mul_op factor)*
//?factor: _factor_op factor | power
//
//!_factor_op: "+"|"-"|"~"
//!_add_op: "+"|"-"
//!_shift_op: "<<"|">>"
//!_mul_op: "*"|"@"|"/"|"%"|"//"
//// <> isn't actually a valid comparison operator in Python. It's here for the
//// sake of a __future__ import described in PEP 401 (which really works :-)
//!_comp_op: "<"|">"|"=="|">="|"<="|"<>"|"!="|"in"|"not" "in"|"is"|"is" "not"


%ignore WS
%ignore CPP_COMMENT
%ignore C_COMMENT

num: ( HEX_NUMBER | NUMBER | OCT_NUMBER | BIN_NUMBER) -> literal

!_factor_op: "+"|"-"

str: ESCAPED_STRING  -> literal
ident: CNAME
array_indexing: ident "[" expr "]"

?group: num | str | array_indexing
    | ident
    | call
    | "(" expr ")"

call:  ident "(" ( expr ( "," expr )* )? ")"

?factor: (_factor_op factor) | group

?mult: factor
    | mult ( MUL | DIV ) group  -> bin_op

?add: mult
    | add ( ADD | SUB ) mult  -> bin_op

?compare1: add
    | add ( GT | LT | GE | LE ) add  -> bin_op

?compare2: compare1
    | compare1 ( EQUALS | NEQUALS ) compare1  -> bin_op

?logical_and: compare2
    | logical_and AND compare2  -> bin_op

?logical_or: logical_and
    | logical_or OR logical_and  -> bin_op

?expr: logical_or

?var_decl_inner: ident
    | ident "=" expr  -> assign

vars_decl: ident var_decl_inner ( "," var_decl_inner )*

array_declaration: ident ident "[" expr "]"

?simple_stmt: ident "=" expr  -> assign
    | call
    | array_indexing "=" expr -> assign
    | expr

?for_stmt_list: vars_decl
    | ( simple_stmt ( "," simple_stmt )* )?  -> stmt_list

?for_cond: expr
    |   -> stmt_list

?body: stmt
    | ";"  -> stmt_list

?argument: array_declaration
    | ident ident

argument_list: (argument ( "," argument )*)?

return_type: ident | (ident ARR)

function: return_type ident "(" argument_list ")" "{" stmt_list "}"

?stmt: ";" -> stmt_list
    | "while" "(" expr ")" body -> while
    | vars_decl ";"
    | "if" "(" expr ")" body -> if
    | "if" "(" expr ")" body "else" body  -> if
    | "for" "(" for_stmt_list ";" for_cond ";" for_stmt_list ")" body  -> for
    | "{" stmt_list "}"
    | simple_stmt ";"
    | function
    | array_declaration ";"
    | "return" expr? ";" -> return

stmt_list: ( stmt ";"* )*

?prog: stmt_list

?start: prog

